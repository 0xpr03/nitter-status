//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.3

use std::time::Duration;

use chrono::Utc;
use sea_orm::{entity::prelude::*, ActiveValue};
use sea_query::{OnConflictUpdate, OnConflict};
use serde::Serialize;

pub const KIND_VERIFICATION: i32 = 1;
pub const KIND_ALERT: i32 = 2;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]
#[sea_orm(table_name = "last_mail_send")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub mail: String,
    pub kind: i32,
    pub time: i64,
}

impl Model {
    /// Update time of last send mail for mail with specified kind
    pub async fn update_last_send<T>(db: &T, mail: String, kind: i32) -> std::result::Result<(),sea_orm::DbErr>
    where T: ConnectionTrait {
        Entity::insert(ActiveModel {
            mail: ActiveValue::Set(mail),
            kind: ActiveValue::Set(kind),
            time: ActiveValue::Set(Utc::now().timestamp()),
        }).on_conflict(OnConflict::columns([Column::Mail,Column::Kind])
        .update_column(Column::Time).to_owned()).exec(db).await?;
        Ok(())
    }
    /// Check if for the specified mail and kind the timeout is reached to send another mail
    pub async fn can_send<T>(db: &T, mail: &str, kind: i32, threshold: i64) -> std::result::Result<bool,sea_orm::DbErr>
    where T: ConnectionTrait {
        let res = Entity::find()
            .filter(Column::Mail.eq(mail))
            .filter(Column::Kind.eq(kind))
            .one(db).await?;
        Ok(res.map_or(true, |v|(Utc::now().timestamp() - v.time).abs() > threshold))
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}
