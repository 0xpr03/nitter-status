//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use sea_orm::{entity::prelude::*, FromQueryResult};
use sea_query::{Query, Order, Alias, SimpleExpr};
use serde::Serialize;

use crate::check_errors;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]
#[sea_orm(table_name = "health_check")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub time: i64,
    #[sea_orm(primary_key, auto_increment = false)]
    pub host: i32,
    pub resp_time: Option<i32>,
    pub healthy: bool,
    pub response_code: Option<i32>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::host::Entity",
        from = "Column::Host",
        to = "super::host::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Host,
}

impl Related<super::host::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Host.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, FromQueryResult, Serialize)]
pub struct HealthyAmount {
    pub time: i64,
    pub alive: i64,
    pub dead: i64,
}

impl HealthyAmount {
    /// Fetch health check graph data for all or selected hosts in the selected time range. 
    pub async fn fetch(db: &DatabaseConnection, from: DateTimeUtc, to: DateTimeUtc, hosts: Option<&[i32]>) -> Result<Vec<HealthyAmount>,DbErr> {
        let builder = db.get_database_backend();
        let mut stmt: sea_query::SelectStatement = Query::select();
        stmt.column(self::Column::Time)
            .expr_as(SimpleExpr::Custom("SUM(healthy)".to_string()), Alias::new("alive"))
            .expr_as(SimpleExpr::Custom("SUM(1-healthy)".to_string()), Alias::new("dead"))
            .group_by_col(self::Column::Time)
            .from(self::Entity)
            .and_where(self::Column::Time.between(from.timestamp(), to.timestamp()));
        if let Some(hosts)  = hosts {
            stmt.and_where(self::Column::Host.is_in(hosts.iter().map(|v| *v)));
        }
        stmt.group_by_col(self::Column::Time)
            .order_by(self::Column::Time, Order::Asc);
        HealthyAmount::find_by_statement(builder.build(&stmt)).all(db).await
    }
}

#[cfg(test)]
mod test {

    use super::*;
    use chrono::Utc;
    use migration::MigratorTrait;
    use sea_orm::{ConnectOptions, Database};

    pub(crate) async fn db_init() -> DatabaseConnection {
        let db = Database::connect(ConnectOptions::new(
            "sqlite:./test_db.db?mode=rwc".to_owned(),
        ))
        .await
        .unwrap();
        migration::Migrator::up(&db, None).await.unwrap();
        db
    }
    #[tokio::test(flavor = "multi_thread", worker_threads = 1)]
    #[ignore]
    async fn test_fetch_instance_list() {
        let db = db_init().await;
        let time_now = Utc::now();
        let time_3h = time_now
            .checked_sub_signed(chrono::Duration::days(14))
            .unwrap();
        let hosts = vec![1,2,3];
        HealthyAmount::fetch(&db, time_3h, time_now,Some(&hosts)).await.unwrap();
    }
}