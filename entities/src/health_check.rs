//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use sea_orm::{entity::prelude::*, FromQueryResult, Statement, StatementBuilder};
use sea_query::{
    Alias, CommonTableExpression, Cond, Order, Query, QueryStatementWriter, SimpleExpr, SqliteQueryBuilder, WithClause
};
use serde::Serialize;

use crate::{check_errors, instance_stats};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]
#[sea_orm(table_name = "health_check")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub time: i64,
    #[sea_orm(primary_key, auto_increment = false)]
    pub host: i32,
    pub resp_time: Option<i32>,
    pub healthy: bool,
    pub response_code: Option<i32>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::host::Entity",
        from = "Column::Host",
        to = "super::host::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Host,
}

impl Related<super::host::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Host.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, FromQueryResult, Serialize)]
pub struct HealthyAmount {
    pub time: i64,
    pub alive: i64,
    pub dead: i64,
}

#[derive(Debug, FromQueryResult, Serialize)]
pub struct InstanceGraphEntry {
    pub time: i64,
    pub alive: i64,
    pub dead: i64,
    pub limited_accs_avg: Option<u32>,
    pub total_accs_avg: Option<u32>,
    pub total_requests_avg: Option<i64>,
}

impl HealthyAmount {
    /// Fetch health check graph data for all or selected hosts in the selected time range.
    pub async fn fetch(
        db: &DatabaseConnection,
        from: Option<DateTimeUtc>,
        to: Option<DateTimeUtc>,
        hosts: Option<&[i32]>,
    ) -> Result<Vec<Self>, DbErr> {
        let builder = db.get_database_backend();
        let mut stmt: sea_query::SelectStatement = Query::select();
        stmt.column(self::Column::Time)
            .expr_as(
                SimpleExpr::Custom("SUM(healthy)".to_string()),
                Alias::new("alive"),
            )
            .expr_as(
                SimpleExpr::Custom("SUM(1-healthy)".to_string()),
                Alias::new("dead"),
            )
            .group_by_col(self::Column::Time)
            .from(self::Entity);
        if let (Some(from), Some(to)) = (from, to) {
            stmt.and_where(self::Column::Time.between(from.timestamp(), to.timestamp()));
        }
        if let Some(hosts) = hosts {
            stmt.and_where(self::Column::Host.is_in(hosts.iter().map(|v| *v)));
        }
        stmt.group_by_col(self::Column::Time)
            .order_by(self::Column::Time, Order::Asc);
        Self::find_by_statement(builder.build(&stmt)).all(db).await
    }
}

impl InstanceGraphEntry {
    /// Fetch health check graph data for all or selected hosts in the selected time range.
    pub async fn fetch(
        db: &DatabaseConnection,
        to: Option<DateTimeUtc>,
    ) -> Result<Vec<Self>, DbErr> {
        let builder = db.get_database_backend();

        let cte_stats = {
            let mut stmt_stats = Query::select();

            let columns: [&str; 3] = ["limited_accs", "total_accs", "total_requests"];
            stmt_stats.column(instance_stats::Column::Time);
            for col in columns {
                stmt_stats.expr_as(
                    Expr::cust(format!("AVG({col})")),
                    Alias::new(format!("{col}_avg")),
                );
            }
            stmt_stats
                .from(instance_stats::Entity)
                .group_by_col(self::Column::Time)
                .order_by(self::Column::Time, Order::Asc);
            let mut cte_stats = CommonTableExpression::from_select(stmt_stats);
            cte_stats.table_name(Alias::new("stats"));
            cte_stats
        };

        let mut cte_health = {
            let mut stmt_health = Query::select();
            stmt_health //.expr_as(SimpleExpr::Custom("strftime('%Y/%m/%d %H:%M:%S', datetime(time, 'unixepoch', 'utc'))".to_string()), Alias::new("time"))
                .column(self::Column::Time)
                .expr_as(
                    SimpleExpr::Custom("SUM(healthy)".to_string()),
                    Alias::new("alive"),
                )
                .expr_as(
                    SimpleExpr::Custom("SUM(1-healthy)".to_string()),
                    Alias::new("dead"),
                )
                .group_by_col(self::Column::Time)
                .from(self::Entity);
            if let Some(to) = to {
                stmt_health.and_where(self::Column::Time.lte(to.timestamp()));
            }
            stmt_health
                .group_by_col(self::Column::Time)
                .order_by(self::Column::Time, Order::Asc);
            let mut cte = CommonTableExpression::from_select(stmt_health);
            cte.table_name(Alias::new("health"));
            cte
        };

        let with_clause = WithClause::new()
            .recursive(false)
            .cte(cte_health)
            .cte(cte_stats)
            .to_owned();

        let select = Query::select()
            .expr_as(
                SimpleExpr::Custom("health.time".to_string()),
                Alias::new("time"),
            )
            .expr_as(
                SimpleExpr::Custom("health.alive".to_string()),
                Alias::new("alive"),
            )
            .expr_as(
                SimpleExpr::Custom("health.dead".to_string()),
                Alias::new("dead"),
            )
            .expr_as(
                SimpleExpr::Custom("stats.limited_accs_avg".to_string()),
                Alias::new("limited_accs_avg"),
            )
            .expr_as(
                SimpleExpr::Custom("stats.total_accs_avg".to_string()),
                Alias::new("total_accs_avg"),
            )
            .expr_as(
                SimpleExpr::Custom("stats.total_requests_avg".to_string()),
                Alias::new("total_requests_avg"),
            )
            .left_join(Alias::new("stats"), Expr::cust("health.time = stats.time"))
            .from(Alias::new("health"))
            .to_owned();

        let final_query = with_clause.query(select).to_owned();

        // how to query this native, without this statement -> sql string -> query hack
        // Self::find_by_statement(builder.build(&final_query)).all(db).await
        let sql = final_query.build(SqliteQueryBuilder).0;
        println!("{sql}");
        Self::find_by_statement(Statement::from_string(
            db.get_database_backend(),
            sql,
        ))
        .all(db)
        .await
    }
}

#[cfg(test)]
mod test {

    use super::*;
    use chrono::Utc;
    use migration::MigratorTrait;
    use sea_orm::{ConnectOptions, Database};

    pub(crate) async fn db_init() -> DatabaseConnection {
        let db = Database::connect(ConnectOptions::new(
            "sqlite:./test_db.db?mode=rwc".to_owned(),
        ))
        .await
        .unwrap();
        migration::Migrator::up(&db, None).await.unwrap();
        db
    }
    #[tokio::test(flavor = "multi_thread", worker_threads = 1)]
    #[ignore]
    async fn test_fetch_instance_list() {
        let db = db_init().await;
        let time_now = Utc::now();
        let time_3h = time_now
            .checked_sub_signed(chrono::Duration::days(14))
            .unwrap();
        let hosts = vec![1, 2, 3];
        HealthyAmount::fetch(&db, Some(time_3h), Some(time_now), Some(&hosts))
            .await
            .unwrap();
    }
}
