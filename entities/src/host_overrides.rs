//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use sea_orm::entity::prelude::*;
use serde::Serialize;

use crate::host;

/// Module of override keys
pub mod keys {
    use std::{collections::HashMap, sync::LazyLock};

    use sea_orm::{
        ActiveModelTrait, ActiveValue, ColumnTrait, DatabaseConnection, DbErr, EntityTrait,
        QueryFilter,
    };
    use sea_query::OnConflict;
    use serde::Serialize;
    use tracing::warn;

    use super::{Column, Entity};
    use crate::host;
    pub type Result<T> = std::result::Result<T, DbErr>;

    /// Override key to mark host as blocking health checks
    pub const KEY_BAD_HOST: &str = "BAD_HOST";
    /// Expected value for a true value
    pub const VAL_BOOL_TRUE: &str = "true";
    /// Override key for host health path to check
    pub const KEY_HOST_HEALTH_PATH: &str = "HEALTH_PATH";
    /// Override key for host health query to check
    pub const KEY_HOST_HEALTH_QUERY: &str = "HEALTH_QUERY";
    /// Override key for host bearer token
    pub const KEY_HOST_BEARER: &str = "BEARER_TOKEN";
    pub const LOCKED_TRUE: i32 = 1;
    pub const LOCKED_FALSE: i32 = 0;
    /// Overrides that aren't locked by default
    pub static NOT_LOCKED_DEFAULTS: &'static [&'static str] =
        &[KEY_HOST_HEALTH_PATH, KEY_HOST_BEARER, KEY_HOST_HEALTH_QUERY];

    pub static ALL_OVERRIDES: &'static [&'static str] =
        &[KEY_BAD_HOST, KEY_HOST_BEARER, KEY_HOST_HEALTH_PATH, KEY_HOST_HEALTH_QUERY];

    #[derive(Serialize, Clone, Copy)]
    pub enum ValueType {
        String,
        Bool,
    }

    static KEY_TYPES: LazyLock<HashMap<&str, ValueType>> = LazyLock::new(|| {
        HashMap::from([
            (KEY_BAD_HOST, ValueType::Bool),
            (KEY_HOST_HEALTH_PATH, ValueType::String),
            (KEY_HOST_HEALTH_QUERY, ValueType::String),
            (KEY_HOST_BEARER, ValueType::String),
        ])
    });

    #[derive(Serialize)]
    pub struct Override {
        pub value: Option<String>,
        pub locked: bool,
        pub value_type: ValueType,
    }

    impl Override {
        fn new(value_type: ValueType, key: &&str) -> Self {
            Self {
                value: Default::default(),
                locked: !NOT_LOCKED_DEFAULTS.contains(key),
                value_type,
            }
        }
    }
    /// Host overrides for a single host
    pub struct HostOverrides {
        host: i32,
        /// Key -> Override
        entries: HashMap<String, Override>,
    }
    impl HostOverrides {
        /// Load HostOverrides for a given domain - will be empty if not found
        pub async fn load_by_domain(domain: &str, db: &DatabaseConnection) -> Result<Self> {
            let host = host::Entity::find()
                .filter(host::Column::Domain.eq(domain))
                .one(db)
                .await?;
            match host {
                None => Ok(Self {
                    host: -1,
                    entries: HashMap::new(),
                }),
                Some(host) => Self::load(&host, db).await,
            }
        }

        pub async fn load(host: &host::Model, db: &DatabaseConnection) -> Result<Self> {
            let mut overrides: HashMap<String, _> = KEY_TYPES
                .iter()
                .map(|(key, value_type)| (key.to_string(), Override::new(*value_type, key)))
                .collect();

            let entries = Entity::find()
                .filter(Column::Host.eq(host.id))
                .all(db)
                .await?;

            entries.into_iter().for_each(|fetched_entry| {
                if let Some(entry) = overrides.get_mut(&fetched_entry.key) {
                    entry.value = fetched_entry.value;
                    entry.locked = fetched_entry.locked == LOCKED_TRUE;
                } else {
                    warn!(
                        host = host.id,
                        key = fetched_entry.key,
                        "Found unknown override key!"
                    );
                }
            });
            Ok(Self {
                host: host.id,
                entries: overrides,
            })
        }

        /// Retrieve [KEY_HOST_BEARER]
        pub fn bearer(&self) -> Option<&str> {
            self.get(KEY_HOST_BEARER)
        }

        /// Retrieve [KEY_HOST_HEALTH_PATH]
        pub fn health_path(&self) -> Option<&str> {
            self.get(KEY_HOST_HEALTH_PATH)
        }
        
        /// Retrieve [KEY_HOST_HEALTH_QUERY]
        pub fn health_query(&self) -> Option<&str> {
            self.get(KEY_HOST_HEALTH_QUERY)
        }

        /// Retrieve override value for key
        pub fn get(&self, key: &str) -> Option<&str> {
            self.entries
            .get(key)
            .and_then(|v| v.value.as_deref())
        }

        pub fn entries(&self) -> &HashMap<String, Override> {
            &self.entries
        }

        pub fn host(&self) -> i32 {
            self.host
        }

        /// Returns whether an entry is locked, will be true if not found
        pub async fn is_locked(&self, key: &str) -> bool {
            self.entries.get(key).map(|v| v.locked).unwrap_or(true)
        }

        pub async fn update_value(
            &mut self,
            key: String,
            value: Option<String>,
            db: &DatabaseConnection,
        ) -> Result<()> {
            match self.entries.get_mut(&key) {
                Some(entry) => {
                    if entry.value == value {
                        return Ok(());
                    }
                    entry.value = value;
                    let locked_val = match entry.locked {
                        true => LOCKED_TRUE,
                        false => LOCKED_FALSE,
                    };
                    super::Entity::insert(super::ActiveModel {
                        host: ActiveValue::Set(self.host),
                        key: ActiveValue::Set(key),
                        locked: ActiveValue::Set(locked_val),
                        value: ActiveValue::Set(entry.value.clone()),
                    })
                    .on_conflict(
                        dbg!(OnConflict::columns([Column::Key, Column::Host]))
                            .update_columns([Column::Locked, Column::Value])
                            .to_owned(),
                    )
                    .exec(db)
                    .await?;
                    Ok(())
                }
                None => todo!(),
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]
#[sea_orm(table_name = "host_overrides")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub host: i32,
    #[sea_orm(primary_key)]
    pub key: String,
    pub locked: i32,
    pub value: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::host::Entity",
        from = "Column::Host",
        to = "super::host::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Host,
}

impl Related<super::host::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Host.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
